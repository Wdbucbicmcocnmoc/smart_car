C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Seror
OBJECT MODULE PLACED IN .\Out_File\Seror.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE Seror.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\..\Libraries\lib
                    -raries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src) DEBUG PRI
                    -NT(.\Out_File\Seror.lst) TABS(2) OBJECT(.\Out_File\Seror.obj) 

stmt  level    source

    1          /*      æ¯æ—¥ä¸€æ‹œ å¥½è¿‡çœèµ›             å¤©å¤©å‚æ‹œ ç¨³è¿‡å›½èµ›        */
    2          /* \\ \\ \\ \\ \\ \\ \\ || || || || || || // // // // // // // //
    3          \\ \\ \\ \\ \\ \\ \\        _ooOoo_          // // // // // // //
    4          \\ \\ \\ \\ \\ \\          o8888888o            // // // // // //
    5          \\ \\ \\ \\ \\             88" . "88               // // // // //
    6          \\ \\ \\ \\                (| -_- |)                  // // // //
    7          \\ \\ \\                   O\  =  /O                     // // //
    8          \\ \\                   ____/`---'\____                     // //
    9          \\                    .'  \\|     |//  `.                      //
   10          ==                   /  \\|||  :  |||//  \                     ==
   11          ==                  /  _||||| -:- |||||-  \                    ==
   12          ==                  |   | \\\  -  /// |   |                    ==
   13          ==                  | \_|  ''\---/''  |   |                    ==
   14          ==                  \  .-\__  `-`  ___/-. /                    ==
   15          ==                ___`. .'  /--.--\  `. . ___                  ==
   16          ==              ."" '<  `.___\_<|>_/___.'  >'"".               ==
   17          ==            | | :  `- \`.;`\ _ /`;.`/ - ` : | |              \\
   18          //            \  \ `-.   \_ __\ /__ _/   .-` /  /              \\
   19          //      ========`-.____`-.___\_____/___.-`____.-'========      \\
   20          //                           `=---='                           \\
   21          // //   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  \\ \\
   22          // // //      ä½›ç¥–ä¿ä½‘      æ°¸æ— BUG      æ°¸ä¸ä¿®æ”¹        \\ \\ \\
   23          // // // // // // || || || || || || || || || || \\ \\ \\ \\ \\ */
   24          
   25          
   26          #include "headfile.h"
   27          #include "myfile.h"
   28          
   29          //èˆµæœºæé™å€¼
   30          int16 S3010_mid = 702;       //å®šä¹‰èˆµæœºä¸­å€¼
   31          int16 S3010_Left_Max = 780;  //å·¦è¾¹æé™å€¼ï¼Œå³èˆµæœºåˆ°è¿™é‡Œä¸èƒ½å†æ‰“äº†
   32          int16 S3010_Right_Max = 620; //å³è¾¹é“ç†åŒå·¦è¾¹
   33          
   34          float Error = 0, Error_last = 0, Error_angle_out = 0, Steer_duty = 0; //[Error-å·®åˆ«å’Œ angle_out-è§’åº¦
             - Steer_duty-æœ€ç»ˆèˆµæœºè¾“å‡ºå ç©ºæ¯”]
   35          float Kp = 1.2, Kd = 2;                                               //å·®æ¯”å’Œç”¨çš„kp,kd;
   36          //æ–°åˆ†åŒºç”¨åˆ°çš„
   37          float error_value = 0, error_value_old = 0, lor = 0, lor_last = 0, reduce = 0, plus = 0, spaceflag = 95, 
             -ratio = 0, ad_referens = 100, abserror = 0, rp = 0;
   38          float Difference_error = 0; //è¯¯å·®çš„è¯¯å·®
   39          uint8 space_flag = 0;     
   40          //ä¸‰å²”æ ‡å¿—ä½
   41          int8 three_on = 0, three_in_L = 0, three_in_R = 0, numbe = 1; //åˆ†åˆ«æ˜¯ è¯†åˆ«åˆ°ä¸‰å²” è¿›å…¥åˆ°ä¸‰å²”
             -é‡Œ å‡ºä¸‰å²” è®¡æ•°
   42          //åœ†ç¯æ ‡å¿—ä½
   43          int8 Island_Left=0;
   44          int8 Island_Right=0;
   45          int Island_time = 0;
   46          uint8 Huan_finish_count = 0; //ç¯è®¡æ•°//Duan
   47          //åå­—æ ‡å¿—ä½
   48          int8 shizi = 0;
   49          float shizi_p = 1.2, shizi_d = 3.0;
   50          //ç›´é“pd
   51          float zhidao_p = 1.20, zhidao_d = 4.0;
   52          //åœ†ç¯PD
   53          float ruhuan_p = 3.2, ruhuan_d = 2.8;
   54          float chuhuan_p = 3.8, chuhuan_d = 2.3;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 2   

   55          float huanz_p = 1.5, huanz_d = 8;
   56          
   57          int SL_In_xishu = 470, SL_Out_xishu = 15; //å·¦å°ç¯å…¥ç¯ç³»æ•°ã€å‡ºç¯ç³»æ•°ï¼Œå·¦å¤§ç¯å…¥ç¯ç³»æ•°ã
             -€å‡ºç¯åç½®å€¼
   58          int SR_In_xishu = 470, SR_Out_xishu = 15; //å³å°ç¯å…¥ç¯ç³»æ•°ã€å‡ºç¯ç³»æ•°ï¼Œå³å¤§ç¯å…¥ç¯ç³»æ•°ã
             -€å‡ºç¯åç½®å€¼
   59          //ç¼–ç å™¨ç§¯åˆ†è·¯ç¨‹ç”¨åˆ°çš„å˜é‡
   60          float road_L = 0, road_R = 0, road_sum = 0;
   61          //å·®æ¯”å’Œç”¨çš„ç³»æ•°
   62          short a = 55; //ç©ºé—´2åŒº
   63          short b = 400;
   64          float error_heng = 0, error_xie = 0;
   65          //å‡ºå…¥åº“æ ‡å¿—ä½
   66          int8 library = 1;      //æ§åˆ¶å‡ºåº“æ‰“è§’ï¼Œä¹Ÿå¯ç”¨æ‹¨ç æ§
   67          uint8 out_garage = 0, out_ku = 0;
   68          int cnt = 0, ruku_time = 60;
   69          int16 yaw_ruku = 0;
   70          float ruku_lucheng = 0;
   71          int16 yaw_chuku = 0;
   72          uint8 inku = 0;
   73          //é™€èºä»ª
   74          int16 yaw_error = 0;
   75          
   76          //åèˆªè§’è¿ç”¨
   77          int16 yaw_angle = 0, yaw_fork = 0;
   78          int16 yaw_different = 0;
   79          
   80          
   81          //ä¸‰å²”pid
   82          float cha_zuo_p = 1, cha_zuo_d = 8.0; // 780
   83          float cha_you_p = 1.2, cha_you_d = 8.0;
   84          int fork_time = 0;
   85          //å¡é“å˜é‡
   86          int8 Ramp = 0;
   87          int16 pitch_poing = 0;
   88          int ramp_time = 0;  //å¡é“å®šæ—¶
   89          
   90          
   91          uint8 Po_finish_count = 0;
   92          
   93          //æ¨¡æ¿åŒ¹é…ç”¨çš„
   94          int8 rank = 0;
   95          
   96          /*********************************************
   97           *å‡½æ•°ï¼šåŒºåŸŸè§£ç®—å‡½æ•°ï¼ˆæ—§ï¼‰
   98           *å‡½æ•°åï¼šPosition_Jud()
   99           *å¤‡æ³¨ï¼š
  100           *æ—¥æœŸï¼š
  101           *ä¿®æ”¹æ—¥æœŸï¼š
  102           *********************************************/
  103          void Position_Jud()
  104          {
  105   1          int16 i;
  106   1          Read_ADC();
  107   1          for (i = 0; i < 7; i += 3)
  108   1          {
  109   2              if (GUI_AD[Max_Front] < GUI_AD[i] - 5)
  110   2                  Max_Front = i;
  111   2          }
  112   1      
  113   1          Position_Transit[0] = 88; //åç¦»0å·ä¼ æ„Ÿå™¨æ—¶3å·ä¼ æ„Ÿå™¨çš„å€¼ //37
  114   1          Position_Transit[1] = 88; //åç¦»5å·ä¼ æ„Ÿå™¨æ—¶3å·ä¼ æ„Ÿå™¨çš„å€¼ //45
  115   1      
  116   1          if (Max_Front == 0 && MAD <= Position_Transit[0] - 1)
  117   1          {
  118   2              Position = 0;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 3   

  119   2          }
  120   1          else if (Max_Front == 0 && MAD >= Position_Transit[0] + 1 || Max_Front == 3 && ZLAD - ZRAD > 1)
  121   1          {
  122   2              Position = 1;
  123   2          }
  124   1          else if (Max_Front == 6 && MAD >= Position_Transit[1] + 1 || Max_Front == 3 && ZRAD - ZLAD > 1)
  125   1          {
  126   2              Position = 2;
  127   2          }
  128   1          else if (Max_Front == 6 && MAD <= Position_Transit[1] - 1)
  129   1          {
  130   2              Position = 3;
  131   2          }
  132   1          if (abs(Position - Position_last) == 3) //å‰æ’ä½ç½®é˜²è·³å˜   é˜²æ­¢ä¸´è¿‘èµ›é“å¹²æ‰°
  133   1          {
  134   2              Position = Position_last;
  135   2          }
  136   1          else
  137   1          {
  138   2              Position_last = Position;
  139   2          }
  140   1      }
  141          /*********************************************
  142           *å‡½æ•°ï¼šæ‰§è¡Œå‡½æ•°
  143           *å‡½æ•°åï¼šcaculation()
  144           *å¤‡æ³¨ï¼š
  145           *ä¿®æ”¹æ—¥æœŸï¼š
  146           *********************************************/
  147          void caculation()
  148          {
  149   1          error_heng = (QLAD - QRAD) / (QLAD + QRAD);
  150   1          error_xie = (XLAD - XRAD) / (XLAD + XRAD);
  151   1          Position_Jud();
  152   1          ZW_judge();
  153   1          Circular_zuo();
  154   1          Circular_syou();
  155   1          Three_branch_road();
  156   1          podao();
  157   1      }
  158          
  159          /*********************************************
  160           *å‡½æ•°ï¼šåˆ†åŒºæ–°ç®—æ³•å‡½æ•°
  161           *å‡½æ•°åï¼šposition_new()
  162           *å¤‡æ³¨ï¼š2022/05/30
  163           *ä¿®æ”¹æ—¥æœŸï¼š
  164           *********************************************/
  165          void position_new()
  166          {
  167   1          Read_ADC();
  168   1          abserror = abs(ad_referens - MAD);
  169   1          ratio = (abserror / ad_referens) * a; // a=50
  170   1          Difference_error = error_value - error_value_old;
  171   1          if (space_flag == 1 && (Position == 1 || Position == 2))
  172   1          {
  173   2              // BEEP = 0;
  174   2              base = base_straight;
  175   2              reduce = sqrt(ZLAD) - sqrt(ZRAD);
  176   2              plus = ZLAD + ZRAD + MAD;
  177   2              rp = (reduce / plus) * b; // b=420;
  178   2              error_value_old = error_value;
  179   2              error_value = rp;
  180   2              Kp = zhidao_p;
  181   2              Kd = zhidao_d;
  182   2              Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  183   2              yaw_different = 0;
  184   2          }
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 4   

  185   1          if (space_flag == 2)
  186   1          {
  187   2              if (error_heng < -0.23 && error_xie < -0.47)     //å³å¼¯
  188   2              {
  189   3                  lor = -1;
  190   3                  error_value_old = error_value;
  191   3                  error_value = lor * ratio;
  192   3                  Kp = Fuzzy_P(error_value, Difference_error);
  193   3                  Kd = Fuzzy_D(error_value, Difference_error);
  194   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  195   3              }
  196   2              if (error_heng > 0.23 && error_xie > 0.27)      //å·¦å¼¯
  197   2              {
  198   3      
  199   3                  lor = 1;
  200   3                  error_value_old = error_value;
  201   3                  error_value = lor * ratio;
  202   3                  Kp = Fuzzy_P(error_value, Difference_error);
  203   3                  Kd = Fuzzy_D(error_value, Difference_error);
  204   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  205   3              }
  206   2          }
  207   1          if (space_flag == 4)
  208   1          {
  209   2              /**********************å·¦ç¯*********************/
  210   2              if (Island_Left == 2)    //å…¥ç¯
  211   2              {
  212   3                  // base = 170;
  213   3                  error_value_old = error_value;
  214   3                  error_value = ((sqrt(ZLAD) * 1.55 - sqrt(ZRAD) * 0.45) * SL_In_xishu) / (ZLAD + ZRAD); // 500
  215   3                  Kp = ruhuan_p + 0.3;
  216   3                  Kd = ruhuan_d + 0.3;
  217   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  218   3                  yaw_error = Yaw - yaw_angle;
  219   3              }
  220   2              if (Island_Left == 3)   //åœ¨ç¯ä¸­ä½¿ç”¨å¼¯é“å¾ªè¿¹
  221   2              {
  222   3                  // base = 170;
  223   3                  error_value_old = error_value;
  224   3                  error_value = ratio;
  225   3                  // Difference_error = error_value - error_value_old;
  226   3                  // Kp = Fuzzy_P(error_value, Difference_error);
  227   3                  // Kd = Fuzzy_D(error_value, Difference_error);
  228   3                  Kp = huanz_p;
  229   3                  Kd = huanz_d;
  230   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  231   3              }
  232   2              if (Island_Left == 4)    //å‡ºç¯
  233   2              {
  234   3                  BEEP = 0;
  235   3                  error_value_old = error_value;
  236   3                  error_value = ratio + SL_Out_xishu;   //æˆ‘çš„å‡ºç¯æ˜¯åœ¨å¼¯é“å¾ªè¿¹çš„åŸºç¡€ä¸Šæ‰‹åŠ¨åŠ è¯
             -¯å·®å€¼
  237   3                                                  //ä¹Ÿå¯ç”¨ç”µæ„Ÿå‡ºç¯ï¼Œå»ºè®®ä½¿ç”¨çŸ­å‰ç»å‡ºç¯
  238   3                  // error_value = ((sqrt(ZLAD) * 1.55 - sqrt(ZRAD) * 0.45) * 350) / (ZLAD + ZRAD);
  239   3                  Kp = chuhuan_p;
  240   3                  Kd = chuhuan_d;
  241   3                  // Kp = ruhuan_p - 0.8;
  242   3                  // Kd = ruhuan_d - 0.6;
  243   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  244   3              }
  245   2              //***************å³ç¯*****************//
  246   2              if (Island_Right == 2)     //å…¥ç¯
  247   2              {
  248   3                  error_value_old = error_value;
  249   3                  error_value = ((sqrt(ZLAD) * 0.45 - sqrt(ZRAD) * 1.55) * SR_In_xishu) / (ZLAD + ZRAD); // 500
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 5   

  250   3                  Kp = ruhuan_p;
  251   3                  Kd = ruhuan_d;
  252   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  253   3                  yaw_error = Yaw - yaw_angle;
  254   3              }
  255   2              if (Island_Right == 3)    //åœ¨ç¯ä¸­
  256   2              {
  257   3                  // base = 170;
  258   3                  error_value_old = error_value;
  259   3                  error_value = -(ratio);
  260   3                  // Difference_error = error_value - error_value_old;
  261   3                  // Kp = Fuzzy_P(error_value, Difference_error);
  262   3                  // Kd = Fuzzy_D(error_value, Difference_error);
  263   3                  Kp = huanz_p;
  264   3                  Kd = huanz_d;
  265   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  266   3              }
  267   2              if (Island_Right == 4)   //å‡ºç¯
  268   2              {
  269   3                  BEEP = 0;
  270   3                  error_value_old = error_value;
  271   3                  error_value = -(ratio + SR_Out_xishu);
  272   3                  // error_value = ((sqrt(ZLAD) * 0.45 - sqrt(ZRAD) * 1.55) * 350) / (ZLAD + ZRAD);
  273   3                  // Kp = ruhuan_p - 1.2;
  274   3                  // Kd = ruhuan_d - 1.2;
  275   3                  Kp = chuhuan_p;
  276   3                  Kd = chuhuan_d;
  277   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  278   3              }
  279   2      
  280   2             //ä¸‰å²”å¤„ç†
  281   2              if (three_on == 1 && space_flag == 4)    //å…¥å²”å›ºå®šæ‰“è§’
  282   2              {
  283   3                  if (numbe % 2 == 0)
  284   3                  {
  285   4                      Error_angle_out = 75;
  286   4                  }
  287   3                  else if (numbe % 2 != 0)
  288   3                  {
  289   4                      Error_angle_out = -75;
  290   4                  }
  291   3                  yaw_different = abs(Yaw - yaw_fork);
  292   3              }
  293   2              if (three_in_L == 1)     //å·¦å²”å¤„ç†
  294   2              {
  295   3                  BEEP = 0;
  296   3                  error_value_old = error_value;
  297   3                  error_value = ((sqrt(XLAD)) * 1.2 - 1.2 * (sqrt(XRAD)) + 0.8 * (sqrt(ZLAD)) - 0.8 * (sqrt(ZRA
             -D))) * 600 / (XLAD + XRAD + ZLAD + ZRAD + MAD);
  298   3                  Kp = cha_zuo_p;
  299   3                  Kd = cha_zuo_d;
  300   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  301   3              }
  302   2              if (three_in_R == 1)    //å³å²”å¤„ç†
  303   2              {
  304   3                  BEEP = 0;
  305   3                  error_value_old = error_value;
  306   3                  error_value = ((sqrt(XLAD)) * 1.2 - 1.2 * (sqrt(XRAD)) + 0.8 * (sqrt(ZLAD)) - 0.8 * (sqrt(ZRA
             -D))) * 600 / (XLAD + XRAD + ZLAD + ZRAD + MAD);
  307   3                  Kp = cha_zuo_p;
  308   3                  Kd = cha_zuo_d;
  309   3                  Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
  310   3              }
  311   2          }
  312   1          //å¡é“å¤„ç†
  313   1          if (Ramp == 1)
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 6   

  314   1          {
  315   2              base = base_ramp;
  316   2          }
  317   1         
  318   1      
  319   1          //æ¨¡æ¿åŒ¹é…éœ€ç”¨åˆ°çš„ï¼Œrankå€¼æ¸…"0"æ‰èƒ½è·‘ç¬¬2åœˆ
  320   1          // if (element_sum == rank)
  321   1          // {
  322   1          //     rank = 0;
  323   1          // }
  324   1      }
  325          
  326          /*********************************************
  327           *å‡½æ•°ï¼šæ¨¡ç³Špidå‡½æ•°
  328           *å‡½æ•°åï¼šmohu_pid()
  329           *å¤‡æ³¨ï¼šè¦æµ‹é‡ è¯¯å·®å€¼ è¯¯å·®çš„å·®å€¼
  330           *æ—¥æœŸï¼š2022/05/30
  331           *ä¿®æ”¹æ—¥æœŸï¼š
  332           *********************************************/
  333          float Fuzzy_P(float E, float EC)
  334          {
  335   1          /*è¾“å…¥é‡Pè¯­è¨€å€¼ç‰¹å¾ç‚¹*/
  336   1          float EFF[7] = {-56, -20, -10, 0, 10, 20, 56};    //ErrorèŒƒå›´
  337   1      
  338   1          /*è¾“å…¥é‡Dè¯­è¨€å€¼ç‰¹å¾ç‚¹*/
  339   1          float DFF[7] = {-2.5, -1.5, -0.5, 0, 0.5, 1.5, 2.5};  // è¯¯å·®å˜åŒ–ç‡èŒƒå›´
  340   1      
  341   1          /*è¾“å‡ºé‡Uè¯­è¨€å€¼ç‰¹å¾ç‚¹(æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„è¾“å‡ºå€¼)*/
  342   1          float UFF[7] = {1.7, 1.8, 1.9, 2.0, 2.1, 2.8, 3}; // 1.15 2  2.2 2.4 2.6 2.8 3 4}
  343   1          // float UFF[7] = {2.0, 2.1, 2.2, 2.4, 2.8, 2.8, 3};
  344   1          int rule[7][7] = {
  345   1              {6, 5, 4, 3, 2, 1, 0},                           //è§„åˆ™è¡¨ï¼Œä¸å»ºè®®ä¿®æ”¹
  346   1              {5, 4, 3, 2, 1, 0, 1},
  347   1              {4, 3, 2, 1, 0, 1, 2},
  348   1              {3, 2, 1, 0, 1, 2, 3},
  349   1              {2, 1, 0, 1, 2, 3, 4},
  350   1              {1, 0, 1, 2, 3, 4, 5},
  351   1              {0, 1, 2, 3, 4, 5, 6},
  352   1          };
  353   1      
  354   1          float U = 0;                                 /*åå·®,åå·®å¾®åˆ†ä»¥åŠè¾“å‡ºå€¼çš„ç²¾ç¡®é‡*/
  355   1          float PF[2] = {0}, DF[2] = {0}, UF[4] = {0}; //åå·®,åå·®å¾®åˆ†ä»¥åŠè¾“å‡ºå€¼çš„éš¶å±åº¦
  356   1      
  357   1          int Pn = 0, Dn = 0, Un[4] = {0};
  358   1          float t1 = 0, t2 = 0, t3 = 0, t4 = 0, temp1 = 0, temp2 = 0;
  359   1          /*éš¶å±åº¦çš„ç¡®å®š*/
  360   1          /*æ ¹æ®PDçš„æŒ‡å®šè¯­è¨€å€¼è·å¾—æœ‰æ•ˆéš¶å±åº¦*/
  361   1          if (E > EFF[0] && E < EFF[6])
  362   1          {
  363   2              if (E <= EFF[1])
  364   2              {
  365   3                  Pn = -2;
  366   3                  PF[0] = (EFF[1] - E) / (EFF[1] - EFF[0]);
  367   3              }
  368   2              else if (E <= EFF[2])
  369   2              {
  370   3                  Pn = -1;
  371   3                  PF[0] = (EFF[2] - E) / (EFF[2] - EFF[1]);
  372   3              }
  373   2              else if (E <= EFF[3])
  374   2              {
  375   3                  Pn = 0;
  376   3                  PF[0] = (EFF[3] - E) / (EFF[3] - EFF[2]);
  377   3              }
  378   2              else if (E <= EFF[4])
  379   2              {
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 7   

  380   3                  Pn = 1;
  381   3                  PF[0] = (EFF[4] - E) / (EFF[4] - EFF[3]);
  382   3              }
  383   2              else if (E <= EFF[5])
  384   2              {
  385   3                  Pn = 2;
  386   3                  PF[0] = (EFF[5] - E) / (EFF[5] - EFF[4]);
  387   3              }
  388   2              else if (E <= EFF[6])
  389   2              {
  390   3                  Pn = 3;
  391   3                  PF[0] = (EFF[6] - E) / (EFF[6] - EFF[5]);
  392   3              }
  393   2          }
  394   1      
  395   1          else if (E <= EFF[0])
  396   1          {
  397   2              Pn = -2;
  398   2              PF[0] = 1;
  399   2          }
  400   1          else if (E >= EFF[6])
  401   1          {
  402   2              Pn = 3;
  403   2              PF[0] = 0;
  404   2          }
  405   1      
  406   1          PF[1] = 1 - PF[0];
  407   1      
  408   1          //åˆ¤æ–­Dçš„éš¶å±åº¦
  409   1          if (EC > DFF[0] && EC < DFF[6])
  410   1          {
  411   2              if (EC <= DFF[1])
  412   2              {
  413   3                  Dn = -2;
  414   3                  DF[0] = (DFF[1] - EC) / (DFF[1] - DFF[0]);
  415   3              }
  416   2              else if (EC <= DFF[2])
  417   2              {
  418   3                  Dn = -1;
  419   3                  DF[0] = (DFF[2] - EC) / (DFF[2] - DFF[1]);
  420   3              }
  421   2              else if (EC <= DFF[3])
  422   2              {
  423   3                  Dn = 0;
  424   3                  DF[0] = (DFF[3] - EC) / (DFF[3] - DFF[2]);
  425   3              }
  426   2              else if (EC <= DFF[4])
  427   2              {
  428   3                  Dn = 1;
  429   3                  DF[0] = (DFF[4] - EC) / (DFF[4] - DFF[3]);
  430   3              }
  431   2              else if (EC <= DFF[5])
  432   2              {
  433   3                  Dn = 2;
  434   3                  DF[0] = (DFF[5] - EC) / (DFF[5] - DFF[4]);
  435   3              }
  436   2              else if (EC <= DFF[6])
  437   2              {
  438   3                  Dn = 3;
  439   3                  DF[0] = (DFF[6] - EC) / (DFF[6] - DFF[5]);
  440   3              }
  441   2          }
  442   1          //ä¸åœ¨ç»™å®šçš„åŒºé—´å†…
  443   1          else if (EC <= DFF[0])
  444   1          {
  445   2              Dn = -2;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 8   

  446   2              DF[0] = 1;
  447   2          }
  448   1          else if (EC >= DFF[6])
  449   1          {
  450   2              Dn = 3;
  451   2              DF[0] = 0;
  452   2          }
  453   1      
  454   1          DF[1] = 1 - DF[0];
  455   1      
  456   1          /*ä½¿ç”¨è¯¯å·®èŒƒå›´ä¼˜åŒ–åçš„è§„åˆ™è¡¨rule[7][7]*/
  457   1          /*è¾“å‡ºå€¼ä½¿ç”¨13ä¸ªéš¶å±å‡½æ•°,ä¸­å¿ƒå€¼ç”±UFF[7]æŒ‡å®š*/
  458   1          /*ä¸€èˆ¬éƒ½æ˜¯å››ä¸ªè§„åˆ™æœ‰æ•ˆ*/
  459   1          Un[0] = rule[Pn + 2][Dn + 2];
  460   1          Un[1] = rule[Pn + 3][Dn + 2];
  461   1          Un[2] = rule[Pn + 2][Dn + 3];
  462   1          Un[3] = rule[Pn + 3][Dn + 3];
  463   1      
  464   1          if (PF[0] <= DF[0]) //æ±‚å°
  465   1              UF[0] = PF[0];
  466   1          else
  467   1              UF[0] = DF[0];
  468   1          if (PF[1] <= DF[0])
  469   1              UF[1] = PF[1];
  470   1          else
  471   1              UF[1] = DF[0];
  472   1          if (PF[0] <= DF[1])
  473   1              UF[2] = PF[0];
  474   1          else
  475   1              UF[2] = DF[1];
  476   1          if (PF[1] <= DF[1])
  477   1              UF[3] = PF[1];
  478   1          else
  479   1              UF[3] = DF[1];
  480   1          /*åŒéš¶å±å‡½æ•°è¾“å‡ºè¯­è¨€å€¼æ±‚å¤§*/
  481   1          if (Un[0] == Un[1])
  482   1          {
  483   2              if (UF[0] > UF[1])
  484   2                  UF[1] = 0;
  485   2              else
  486   2                  UF[0] = 0;
  487   2          }
  488   1          if (Un[0] == Un[2])
  489   1          {
  490   2              if (UF[0] > UF[2])
  491   2                  UF[2] = 0;
  492   2              else
  493   2                  UF[0] = 0;
  494   2          }
  495   1          if (Un[0] == Un[3])
  496   1          {
  497   2              if (UF[0] > UF[3])
  498   2                  UF[3] = 0;
  499   2              else
  500   2                  UF[0] = 0;
  501   2          }
  502   1          if (Un[1] == Un[2])
  503   1          {
  504   2              if (UF[1] > UF[2])
  505   2                  UF[2] = 0;
  506   2              else
  507   2                  UF[1] = 0;
  508   2          }
  509   1          if (Un[1] == Un[3])
  510   1          {
  511   2              if (UF[1] > UF[3])
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 9   

  512   2                  UF[3] = 0;
  513   2              else
  514   2                  UF[1] = 0;
  515   2          }
  516   1          if (Un[2] == Un[3])
  517   1          {
  518   2              if (UF[2] > UF[3])
  519   2                  UF[3] = 0;
  520   2              else
  521   2                  UF[2] = 0;
  522   2          }
  523   1          t1 = UF[0] * UFF[Un[0]];
  524   1          t2 = UF[1] * UFF[Un[1]];
  525   1          t3 = UF[2] * UFF[Un[2]];
  526   1          t4 = UF[3] * UFF[Un[3]];
  527   1          temp1 = t1 + t2 + t3 + t4;
  528   1          temp2 = UF[0] + UF[1] + UF[2] + UF[3]; //æ¨¡ç³Šé‡è¾“å‡º
  529   1          U = temp1 / temp2;
  530   1          return U;
  531   1      }
  532          float Fuzzy_D(float E, float EC)
  533          {
  534   1          /*è¾“å…¥é‡Pè¯­è¨€å€¼ç‰¹å¾ç‚¹*/
  535   1          float EFF[7] = {-56, -20, -10, 0, 10, 25, 56};
  536   1          /*è¾“å…¥é‡Dè¯­è¨€å€¼ç‰¹å¾ç‚¹*/
  537   1          float DFF[7] = {-2.5, -1.5, -0.5, 0, 0.5, 1.5, 2};
  538   1          /*è¾“å‡ºé‡Uè¯­è¨€å€¼ç‰¹å¾ç‚¹(æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„è¾“å‡ºå€¼)*/
  539   1          float UFF[7] = {2.3, 4.2, 8.2, 7, 6, 5, 4};
  540   1          // float UFF[7] = {0.6, 0.9, 1.2, 8, 7, 6, 5};
  541   1      
  542   1          int rule[7][7] = {
  543   1              {0, 1, 2, 3, 4, 5, 6},
  544   1              {1, 2, 3, 4, 5, 6, 5},
  545   1              {2, 3, 4, 5, 6, 5, 4},
  546   1              {3, 4, 5, 6, 5, 4, 3},
  547   1              {4, 5, 6, 5, 4, 3, 2},
  548   1              {5, 6, 5, 4, 3, 2, 1},
  549   1              {6, 5, 4, 3, 2, 1, 0},
  550   1          };
  551   1      
  552   1          float U = 0; /*åå·®,åå·®å¾®åˆ†ä»¥åŠè¾“å‡ºå€¼çš„ç²¾ç¡®é‡*/
  553   1          float PF[2] = {0}, DF[2] = {0}, UF[4] = {0};
  554   1          /*åå·®,åå·®å¾®åˆ†ä»¥åŠè¾“å‡ºå€¼çš„éš¶å±åº¦*/
  555   1          int Pn = 0, Dn = 0, Un[4] = {0};
  556   1          float t1 = 0, t2 = 0, t3 = 0, t4 = 0, temp1 = 0, temp2 = 0;
  557   1          /*éš¶å±åº¦çš„ç¡®å®š*/
  558   1          /*æ ¹æ®PDçš„æŒ‡å®šè¯­è¨€å€¼è·å¾—æœ‰æ•ˆéš¶å±åº¦*/
  559   1          if (E > EFF[0] && E < EFF[6])
  560   1          {
  561   2              if (E <= EFF[1])
  562   2              {
  563   3                  Pn = -2;
  564   3                  PF[0] = (EFF[1] - E) / (EFF[1] - EFF[0]);
  565   3              }
  566   2              else if (E <= EFF[2])
  567   2              {
  568   3                  Pn = -1;
  569   3                  PF[0] = (EFF[2] - E) / (EFF[2] - EFF[1]);
  570   3              }
  571   2              else if (E <= EFF[3])
  572   2              {
  573   3                  Pn = 0;
  574   3                  PF[0] = (EFF[3] - E) / (EFF[3] - EFF[2]);
  575   3              }
  576   2              else if (E <= EFF[4])
  577   2              {
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 10  

  578   3                  Pn = 1;
  579   3                  PF[0] = (EFF[4] - E) / (EFF[4] - EFF[3]);
  580   3              }
  581   2              else if (E <= EFF[5])
  582   2              {
  583   3                  Pn = 2;
  584   3                  PF[0] = (EFF[5] - E) / (EFF[5] - EFF[4]);
  585   3              }
  586   2              else if (E <= EFF[6])
  587   2              {
  588   3                  Pn = 3;
  589   3                  PF[0] = (EFF[6] - E) / (EFF[6] - EFF[5]);
  590   3              }
  591   2          }
  592   1      
  593   1          else if (E <= EFF[0])
  594   1          {
  595   2              Pn = -2;
  596   2              PF[0] = 1;
  597   2          }
  598   1          else if (E >= EFF[6])
  599   1          {
  600   2              Pn = 3;
  601   2              PF[0] = 0;
  602   2          }
  603   1      
  604   1          PF[1] = 1 - PF[0];
  605   1      
  606   1          //åˆ¤æ–­Dçš„éš¶å±åº¦
  607   1          if (EC > DFF[0] && EC < DFF[6])
  608   1          {
  609   2              if (EC <= DFF[1])
  610   2              {
  611   3                  Dn = -2;
  612   3                  DF[0] = (DFF[1] - EC) / (DFF[1] - DFF[0]);
  613   3              }
  614   2              else if (EC <= DFF[2])
  615   2              {
  616   3                  Dn = -1;
  617   3                  DF[0] = (DFF[2] - EC) / (DFF[2] - DFF[1]);
  618   3              }
  619   2              else if (EC <= DFF[3])
  620   2              {
  621   3                  Dn = 0;
  622   3                  DF[0] = (DFF[3] - EC) / (DFF[3] - DFF[2]);
  623   3              }
  624   2              else if (EC <= DFF[4])
  625   2              {
  626   3                  Dn = 1;
  627   3                  DF[0] = (DFF[4] - EC) / (DFF[4] - DFF[3]);
  628   3              }
  629   2              else if (EC <= DFF[5])
  630   2              {
  631   3                  Dn = 2;
  632   3                  DF[0] = (DFF[5] - EC) / (DFF[5] - DFF[4]);
  633   3              }
  634   2              else if (EC <= DFF[6])
  635   2              {
  636   3                  Dn = 3;
  637   3                  DF[0] = (DFF[6] - EC) / (DFF[6] - DFF[5]);
  638   3              }
  639   2          }
  640   1          //ä¸åœ¨ç»™å®šçš„åŒºé—´å†…
  641   1          else if (EC <= DFF[0])
  642   1          {
  643   2              Dn = -2;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 11  

  644   2              DF[0] = 1;
  645   2          }
  646   1          else if (EC >= DFF[6])
  647   1          {
  648   2              Dn = 3;
  649   2              DF[0] = 0;
  650   2          }
  651   1      
  652   1          DF[1] = 1 - DF[0];
  653   1      
  654   1          /*ä½¿ç”¨è¯¯å·®èŒƒå›´ä¼˜åŒ–åçš„è§„åˆ™è¡¨rule[7][7]*/
  655   1          /*è¾“å‡ºå€¼ä½¿ç”¨13ä¸ªéš¶å±å‡½æ•°,ä¸­å¿ƒå€¼ç”±UFF[7]æŒ‡å®š*/
  656   1          /*ä¸€èˆ¬éƒ½æ˜¯å››ä¸ªè§„åˆ™æœ‰æ•ˆ*/
  657   1          Un[0] = rule[Pn + 2][Dn + 2];
  658   1          Un[1] = rule[Pn + 3][Dn + 2];
  659   1          Un[2] = rule[Pn + 2][Dn + 3];
  660   1          Un[3] = rule[Pn + 3][Dn + 3];
  661   1      
  662   1          if (PF[0] <= DF[0]) //æ±‚å°
  663   1              UF[0] = PF[0];
  664   1          else
  665   1              UF[0] = DF[0];
  666   1          if (PF[1] <= DF[0])
  667   1              UF[1] = PF[1];
  668   1          else
  669   1              UF[1] = DF[0];
  670   1          if (PF[0] <= DF[1])
  671   1              UF[2] = PF[0];
  672   1          else
  673   1              UF[2] = DF[1];
  674   1          if (PF[1] <= DF[1])
  675   1              UF[3] = PF[1];
  676   1          else
  677   1              UF[3] = DF[1];
  678   1          /*åŒéš¶å±å‡½æ•°è¾“å‡ºè¯­è¨€å€¼æ±‚å¤§*/
  679   1          if (Un[0] == Un[1])
  680   1          {
  681   2              if (UF[0] > UF[1])
  682   2                  UF[1] = 0;
  683   2              else
  684   2                  UF[0] = 0;
  685   2          }
  686   1          if (Un[0] == Un[2])
  687   1          {
  688   2              if (UF[0] > UF[2])
  689   2                  UF[2] = 0;
  690   2              else
  691   2                  UF[0] = 0;
  692   2          }
  693   1          if (Un[0] == Un[3])
  694   1          {
  695   2              if (UF[0] > UF[3])
  696   2                  UF[3] = 0;
  697   2              else
  698   2                  UF[0] = 0;
  699   2          }
  700   1          if (Un[1] == Un[2])
  701   1          {
  702   2              if (UF[1] > UF[2])
  703   2                  UF[2] = 0;
  704   2              else
  705   2                  UF[1] = 0;
  706   2          }
  707   1          if (Un[1] == Un[3])
  708   1          {
  709   2              if (UF[1] > UF[3])
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 12  

  710   2                  UF[3] = 0;
  711   2              else
  712   2                  UF[1] = 0;
  713   2          }
  714   1          if (Un[2] == Un[3])
  715   1          {
  716   2              if (UF[2] > UF[3])
  717   2                  UF[3] = 0;
  718   2              else
  719   2                  UF[2] = 0;
  720   2          }
  721   1          t1 = UF[0] * UFF[Un[0]];
  722   1          t2 = UF[1] * UFF[Un[1]];
  723   1          t3 = UF[2] * UFF[Un[2]];
  724   1          t4 = UF[3] * UFF[Un[3]];
  725   1          temp1 = t1 + t2 + t3 + t4;
  726   1          temp2 = UF[0] + UF[1] + UF[2] + UF[3]; //æ¨¡ç³Šé‡è¾“å‡º
  727   1          U = temp1 / temp2;
  728   1          return U;
  729   1      }
  730          
  731          /*********************************************
  732           *å‡½æ•°ï¼šç›´å¼¯é“è¯†åˆ«å‡½æ•°
  733           *å‡½æ•°åï¼šZW_judge()
  734           *å¤‡æ³¨ï¼šç”¨é™€èºä»ªè¾…åŠ©å‡ºç¯
  735           *æ—¥æœŸï¼š2022/05/30
  736           *ä¿®æ”¹æ—¥æœŸï¼š
  737           *********************************************/
  738          void ZW_judge()
  739          {
  740   1          if (space_flag != 5 && space_flag != 4 && three_on == 0 && (((error_heng <= 0.23 || error_heng >= -0.
             -23) && (error_xie <= 0.27 || error_xie >= -0.47)) || MAD > spaceflag))
  741   1          {
  742   2              space_flag = 1;
  743   2              // BEEP = 0;
  744   2          }
  745   1          if (MAD <= spaceflag && (error_heng > 0.23 || error_heng < -0.23) && (error_xie > 0.27 || error_xie <
             - -0.47) && space_flag != 4 && three_on == 0 && space_flag != 5 && Ramp == 0)
  746   1          {
  747   2              space_flag = 2;
  748   2              // BEEP = 1;
  749   2          }
  750   1      }
  751          /*********************************************
  752           *å‡½æ•°ï¼šå·¦å°ç¯æ ‡å¿—ä½è¯†åˆ«å‡½æ•°å‡½æ•°
  753           *å‡½æ•°åï¼šCircular_zuo()
  754           *å¤‡æ³¨ï¼šç”¨é™€èºä»ªè¾…åŠ©å‡ºç¯
  755           *æ—¥æœŸï¼š2022/05/30
  756           *ä¿®æ”¹æ—¥æœŸï¼š
  757           *********************************************/
  758          
  759          void Circular_zuo()
  760          {
  761   1          if (!Po_control_Location && MAD > 165 && MAD <= 250 && QLAD > 130 && Island_Left == 0 && Ramp == 0) 
  762   1          {                                                                                                    
             -                                                                                                  
  763   2              Island_Left = 1;
  764   2          }
  765   1          //å› ä¸ºä¸åŒé€Ÿåº¦ å…¥ç¯ç‚¹ä¼šä¸å†åŒä¸€ä¸ªåœ°æ–¹ å› æ­¤éœ€è¦åˆ†æ¡ä»¶åˆ¤æ–­ MAD<188 || QLAD<98
  766   1          // if (Circular_BL1 == 1 && ((((FXLAD > 145 && FXLAD < 230)) && P63 == 1 && P61 == 0) || (P61 == 1 &&
             - P63 == 0 && (FXLAD > 140 && FXLAD < 235)) || (P61 == 1 && P63 == 1 && (FXLAD > 140 && FXLAD < 235)) || (P61 == 0 && P63
             - == 0 && (FXLAD > 135 && FXLAD < 250)))) // 185 || QLAD<97 MAD<188
  767   1          // {
  768   1          // space_flag = 4;
  769   1          //     Circular_BL1 = 0;
  770   1          //     Circular_BL2 = 1;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 13  

  771   1          //     // base = 160;
  772   1          //     yaw_angle = Yaw;
  773   1          //     BEEP = 0;
  774   1          // }
  775   1          if (FXLAD > 130 && FXLAD < 235 && MAD > 200 && MAD < 250 && FXLAD > FXRAD && (FSLAD - FSRAD) >= 27 &&
             - Island_Left == 1)
  776   1          {
  777   2              Island_Left = 2;
  778   2              space_flag = 4;
  779   2              // base = 160;
  780   2              yaw_angle = Yaw;
  781   2              BEEP = 0;
  782   2          }
  783   1          if (abs(Yaw - yaw_angle) > 25 && Island_Left == 2)
  784   1          {
  785   2              Island_Left = 3;
  786   2              yaw_error = 0;
  787   2              BEEP = 1;
  788   2          }
  789   1          if (Island_Left == 3 && abs(Yaw - yaw_angle) >= 270) //  XLAD>105
  790   1          {
  791   2              Island_Left = 4;
  792   2              BEEP = 0;
  793   2          }
  794   1          if (Island_Left == 4 && abs(Yaw - yaw_angle) >= 310) //
  795   1          {
  796   2              Island_Left = 5;
  797   2              yaw_angle = 0;
  798   2              three_on = 0;
  799   2              three_in_L = 0;
  800   2              three_in_R = 0;
  801   2              Huan_finish_count++;  // Duan
  802   2              if (MAD >= spaceflag) //åœ¨ä¸€åŒº
  803   2              {
  804   3                  space_flag = 1;
  805   3              }
  806   2              if (MAD < spaceflag)
  807   2              {
  808   3                  space_flag = 2;
  809   3              }
  810   2          }
  811   1          if (Island_Left == 5 && Island_time > 150)
  812   1          {
  813   2              Island_Left = 0;
  814   2          }
  815   1      }
  816          
  817          void Circular_syou()
  818          {
  819   1          if (!Po_control_Location && MAD > 160 && MAD <= 250 && QRAD > 110 && Island_Right == 0 && Ramp == 0) 
             -// 185 && Round_Circular_Left == 0
  820   1          {
  821   2              Island_Right = 1;
  822   2          }
  823   1          if (MAD > 190 && MAD <= 250 && FXRAD > 115 && FXRAD < 175 && FXRAD > FXLAD && (FSRAD - FSLAD) >= 25 &
             -& Island_Right == 1 ) 
  824   1          {
  825   2              Island_Right = 2;
  826   2              yaw_angle = Yaw;
  827   2              space_flag = 4;
  828   2              BEEP = 0;
  829   2          }
  830   1          if (abs(Yaw - yaw_angle) > 30 && Island_Right == 2)
  831   1          {
  832   2              Island_Right = 3;
  833   2              yaw_error = 0;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 14  

  834   2              BEEP = 1;
  835   2          }
  836   1          if (Island_Right == 3 && abs(Yaw - yaw_angle) >= 270) //  XLAD>105
  837   1          {
  838   2              Island_Right = 4;
  839   2              BEEP = 0;
  840   2          }
  841   1          if (Island_Right == 4 && abs(Yaw - yaw_angle) >= 330) //
  842   1          {
  843   2              Island_Right = 5;
  844   2              yaw_angle = 0;
  845   2              three_on = 0;
  846   2              three_in_L = 0;
  847   2              three_in_R = 0;
  848   2              Huan_finish_count++; // Duan
  849   2              if (MAD >= spaceflag) //åœ¨ä¸€åŒº
  850   2              {
  851   3                  space_flag = 1;
  852   3              }
  853   2              if (MAD < spaceflag)
  854   2              {
  855   3                  space_flag = 2;
  856   3              }
  857   2          }
  858   1      
  859   1          //å®šæ—¶æ¶ˆç¯
  860   1          if (Island_Right == 5 && Island_time > 150)
  861   1          {
  862   2              Island_Right = 0;
  863   2          }
  864   1      }
  865          
  866          /*********************************************
  867           *å‡½æ•°ï¼šä¸‰å²”è¯†åˆ«å‡½æ•°å‡½æ•°
  868           *å‡½æ•°åï¼šThree_branch_road()
  869           *å¤‡æ³¨ï¼šè·‘è½¦æ—¶è¦æŠŠå±å¹•å…³æ‰ã€‚
  870           *æ—¥æœŸï¼š2022/05/30
  871           *ä¿®æ”¹æ—¥æœŸï¼š
  872           *********************************************/
  873          void Three_branch_road()
  874          {
  875   1          if (FXLAD >= 25 && FXLAD <= 70 && FXRAD >= 35 && FXRAD <= 85 && FSLAD >= 15 && FSLAD <= 38 && FMAD >=
             - 40 && FMAD < 100 && QLAD < 70 && QRAD < 80 && three_in_L == 0 && three_in_R == 0 && three_on == 0 && Island_Left == 0 &
             -& Island_Right == 0 && Ramp == 0) // order[rank] == Tab_Fork ä½¿ç”¨æ¨¡æ¿åŒ¹é…æ—¶éœ€æ·»åŠ 
  876   1          {
  877   2              three_on = 1;
  878   2              space_flag = 4;
  879   2              BEEP = 1;
  880   2              yaw_fork = Yaw;
  881   2              Po_finish_count = 0;   //
  882   2              Huan_finish_count = 0; //
  883   2              if (numbe % 2 == 0)
  884   2              {
  885   3                  base = 140;
  886   3              }
  887   2              if (numbe % 2 != 0)
  888   2              {
  889   3                  base = 140;
  890   3                  // BEEP=1;
  891   3              }
  892   2          }
  893   1          if (yaw_different >= 20 && three_on == 1 && (numbe % 2 == 0)) //æ¶ˆä¸‰å²”
  894   1          {
  895   2              three_on = 0;
  896   2              three_in_L = 1;
  897   2              yaw_different = 0;
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 15  

  898   2              base = base_fork;
  899   2          }
  900   1          if (yaw_different >= 20 && three_on == 1 && (numbe % 2 != 0)) //æ¶ˆä¸‰å²”
  901   1          {
  902   2              three_on = 0;
  903   2              three_in_R = 1;
  904   2              yaw_different = 0;
  905   2              base = base_fork;
  906   2          }
  907   1          if (three_in_L == 1 && (FXLAD >= 90 || FSLAD >= 91))
  908   1          {
  909   2              three_in_L = 0;
  910   2              three_on = 0;
  911   2              base = 100;
  912   2              numbe = 1;
  913   2              space_flag = 2;
  914   2          }
  915   1          if (three_in_R == 1 && FXRAD >= 90 && FXLAD < 35)
  916   1          {
  917   2              three_in_R = 0;
  918   2              three_on = 0;
  919   2              Ramp = 0;
  920   2              base = 130;
  921   2              numbe = 0;
  922   2              space_flag = 2;
  923   2          }
  924   1      }
  925          
  926          /*********************************************
  927           *å‡½æ•°ï¼šå¡é“è¯†åˆ«å‡½æ•°
  928           *å‡½æ•°åï¼špodao()
  929           *å¤‡æ³¨ï¼šè·‘è½¦æ—¶è¦æŠŠå±å¹•å…³æ‰ã€‚
  930           *æ—¥æœŸï¼š2022/08/11
  931           *ä¿®æ”¹æ—¥æœŸï¼š
  932           *********************************************/
  933          void podao()
  934          {
  935   1          if (Po_control_order == 0 && Po_control_Location == 0)
  936   1          {
  937   2              if (Pitch >= 4 && Ramp == 0 && MAD > 60)
  938   2              {
  939   3                  Ramp = 1;
  940   3                  pitch_poing = Pitch;
  941   3                  BEEP = 1;
  942   3              }
  943   2              if (Ramp == 1 && (((Pitch - pitch_poing) <= -10) || ramp_time > 600))
  944   2              {
  945   3                  Ramp = 0;
  946   3                  BEEP = 0;
  947   3              }
  948   2          }
  949   1          else if (Po_finish_count == 0 && (Po_control_Location == 1 || Po_control_Location == 2))
  950   1          {
  951   2              if (Ramp == 0 && FMAD > 160)
  952   2              {
  953   3                  Ramp = 1;
  954   3                  BEEP = 1;
  955   3              }
  956   2              else if (Ramp == 1 && ramp_time > 600)
  957   2              {
  958   3                  Ramp = 0;
  959   3                  BEEP = 0;
  960   3                  Po_finish_count++;
  961   3                  Po_control_Location = 0;
  962   3              }
  963   2          }
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 16  

  964   1      }
  965          
  966          /*********************************************
  967           *å‡½æ•°ï¼šåå­—è¯†åˆ«å‡½æ•°(æ²¡ç”¨åˆ°)
  968           *å‡½æ•°åï¼šcross_ten()
  969           *å¤‡æ³¨ï¼šè·‘è½¦æ—¶è¦æŠŠå±å¹•å…³æ‰ã€‚
  970           *æ—¥æœŸï¼š2022/08/11
  971           *ä¿®æ”¹æ—¥æœŸï¼š
  972           *********************************************/
  973          void cross_ten()
  974          {
  975   1          if (shizi == 0 && FSLAD > 60 && FSRAD > 60 && space_flag != 4)
  976   1          {
  977   2              shizi = 1;
  978   2              // base = 185;
  979   2              BEEP = 1;
  980   2          }
  981   1          if (shizi == 1 && FSLAD < 15 && FSRAD < 15)
  982   1          {
  983   2              shizi = 2;
  984   2              // base = 170;
  985   2              BEEP = 0;
  986   2          }
  987   1          if (shizi == 2 && FSLAD > 40 && FSRAD > 40)
  988   1          {
  989   2              shizi = 3;
  990   2              BEEP = 1;
  991   2          }
  992   1          if (shizi == 3 && FSLAD < 12 && FSRAD < 12)
  993   1          {
  994   2              shizi = 0;
  995   2              // base = 175;
  996   2              BEEP = 0;
  997   2          }
  998   1      }
  999          
 1000          /*********************************************
 1001           *å‡½æ•°ï¼šæ ‡å¿—ä½æ˜¾ç¤ºå‡½æ•°
 1002           *å‡½æ•°åï¼šADC_show()
 1003           *å¤‡æ³¨ï¼šè·‘è½¦æ—¶è¦æŠŠå±å¹•å…³æ‰ã€‚
 1004           *æ—¥æœŸï¼š2022/05/30
 1005           *ä¿®æ”¹æ—¥æœŸï¼š
 1006           *********************************************/
 1007          void scene_show()
 1008          {
 1009   1          if (P53 == 0)
 1010   1          {
 1011   2              if (P70 == 0) //åˆ‡æ¢æ˜¾ç¤ºæ—¶æŒ‰é”®åˆ·æ–°å±å¹•
 1012   2              {
 1013   3                  delay_ms(10);
 1014   3                  if (P70 == 0)
 1015   3                  {
 1016   4                      while (P70 == 0)
 1017   4                          ;
 1018   4                      oled_fill(0x00);
 1019   4                  }
 1020   3              }
 1021   2              if (P61 == 0)
 1022   2              {
 1023   3                  dianganzhi_show();
 1024   3              }
 1025   2              else if (P61 == 1)
 1026   2              {
 1027   3                  biaozhiwei_show();
 1028   3              }
 1029   2          }
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 17  

 1030   1      
 1031   1          else if (P53 == 1)
 1032   1          {
 1033   2              oled_fill(0x00);
 1034   2          }
 1035   1      }
 1036          void dianganzhi_show()
 1037          {
 1038   1          oled_int16(10, 0, GUI_AD[0]);
 1039   1          oled_int16(10, 1, GUI_AD[1]);
 1040   1          oled_int16(10, 2, GUI_AD[2]);
 1041   1          oled_int16(10, 3, GUI_AD[3]);
 1042   1          oled_int16(10, 4, GUI_AD[4]);
 1043   1          oled_int16(10, 5, GUI_AD[5]);
 1044   1          oled_int16(10, 6, GUI_AD[6]);
 1045   1          oled_int16(10, 7, GUI_AD[7]);
 1046   1          oled_int16(50, 0, GUI_AD[8]);
 1047   1          oled_int16(50, 1, GUI_AD[9]);
 1048   1          oled_int16(50, 2, GUI_AD[10]);
 1049   1          oled_int16(50, 3, GUI_AD[11]);
 1050   1      }
 1051          void biaozhiwei_show()
 1052          {
 1053   1          oled_p6x8str(0, 0, "SL");
 1054   1      
 1055   1          oled_p6x8str(60, 0, "SR");
 1056   1          oled_p6x8str(0, 4, "SC");
 1057   1          oled_p6x8str(60, 4, "Po");
 1058   1          oled_p6x8str(60, 7, "ZandW");
 1059   1      
 1060   1          oled_int16(10, 0, Island_Left);
 1061   1          
 1062   1          oled_int16(80, 0, Island_Right);
 1063   1         
 1064   1          oled_int16(10, 4, three_on);
 1065   1          oled_int16(10, 5, three_in_L);
 1066   1          oled_int16(10, 6, three_in_R);
 1067   1      
 1068   1          oled_int16(80, 4, Ramp);
 1069   1          oled_int16(80, 5, pitch_poing);
 1070   1      
 1071   1          oled_int16(80, 7, space_flag);
 1072   1      }
 1073          
 1074          /*********************************************
 1075           *å‡½æ•°ï¼šèˆµæœºæœ€ç»ˆæ‰“è§’å‡½æ•°
 1076           *å‡½æ•°åï¼šS3010_Direation_Control()
 1077           *å¤‡æ³¨ï¼š
 1078           *æ—¥æœŸï¼š
 1079           *ä¿®æ”¹æ—¥æœŸï¼š
 1080           *********************************************/
 1081          
 1082          void S3010_Direation_Control() //èˆµæœº
 1083          {
 1084   1          caculation();
 1085   1          position_new();
 1086   1          if (Error_angle_out > 80) //èˆµæœºæ‰“è§’é™å¹…
 1087   1              Error_angle_out = 80;
 1088   1          if (Error_angle_out < -80)
 1089   1              Error_angle_out = -80;
 1090   1          Steer_duty = (Error_angle_out + S3010_mid);
 1091   1          if (Steer_duty > S3010_Left_Max)
 1092   1              Steer_duty = S3010_Left_Max; //èˆµæœºå ç©ºæ¯”è¾“å‡ºé™å¹… é˜²æ­¢èˆµæœºçƒ§
 1093   1          if (Steer_duty < S3010_Right_Max)
 1094   1              Steer_duty = S3010_Right_Max;
 1095   1          pwm_duty(PWMB_CH1_P74, Steer_duty); //èˆµæœºæ‰“è§’å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡æ”¹å˜Steer_dutyæ¥å¾—åˆ°èˆµæœ
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 18  

             -ºä¸­å€¼
 1096   1      }
 1097          
 1098          /*********************************************
 1099           *å‡½æ•°ï¼šå‡ºå…¥åº“å‡½æ•°
 1100           *å‡½æ•°åï¼šOut_storage()/In_ku()
 1101           *å¤‡æ³¨ï¼š
 1102           *æ—¥æœŸï¼š2022.06.16
 1103           *ä¿®æ”¹æ—¥æœŸï¼š
 1104           *********************************************/
 1105          void Out_storage()
 1106          {
 1107   1          if (out_ku == 0)
 1108   1          {
 1109   2              base = 200;
 1110   2              if (road_sum >= 0.1 && out_garage == 0)
 1111   2              {
 1112   3                  yaw_chuku = Yaw;
 1113   3                  base = 220;
 1114   3                  out_garage = 1;
 1115   3              }
 1116   2              if (out_garage == 1)
 1117   2              {
 1118   3                  if (library == 0)
 1119   3                  {
 1120   4                      Error_angle_out = -80;
 1121   4                      exp_speed_r = exp_speed_r * (float)(Error_angle_out * (0.008f) + 0.68f);
 1122   4                      exp_speed_l = -(base);
 1123   4                  }
 1124   3                  else if (library != 0)
 1125   3                  {
 1126   4                      Error_angle_out = 80;
 1127   4                      exp_speed_l = exp_speed_l * (float)(Error_angle_out * (-0.008f) + 0.68f);
 1128   4                      exp_speed_r = base;
 1129   4                  }
 1130   3                  Steer_duty = (Error_angle_out + S3010_mid);
 1131   3                  pwm_duty(PWMB_CH1_P74, Steer_duty);
 1132   3                  if (abs(Yaw - yaw_chuku) >= 50)
 1133   3                  {
 1134   4                      out_ku = 1;
 1135   4                      out_garage = 0;
 1136   4                  }
 1137   3              }
 1138   2          }
 1139   1      }
 1140          void In_ku()
 1141          {
 1142   1          Read_ADC();
 1143   1          if (out_ku == 2 && inku == 0)
 1144   1          {
 1145   2              ruku_lucheng = road_sum;
 1146   2              base = 130;
 1147   2              inku = 1;
 1148   2              reduce = sqrt(QLAD) - sqrt(QRAD) + sqrt(XLAD) - sqrt(XLAD);
 1149   2              plus = QLAD + QRAD + MAD + XLAD + XRAD;
 1150   2              rp = (reduce / plus) * b; // b=420;
 1151   2              error_value_old = error_value;
 1152   2              error_value = rp;
 1153   2              Kp = 1.2;
 1154   2              Kd = 3.0;
 1155   2              Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
 1156   2              Steer_duty = (Error_angle_out + S3010_mid);
 1157   2              pwm_duty(PWMB_CH1_P74, Steer_duty);
 1158   2          }
 1159   1          if (inku == 1)
 1160   1          {
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 19  

 1161   2              if (road_sum - ruku_lucheng > 0.25) // 140
 1162   2              {
 1163   3                  BEEP = 1;
 1164   3                  base = -130;
 1165   3                  ruku_lucheng = 0;
 1166   3                  inku = 2;
 1167   3              }
 1168   2          }
 1169   1          if (inku == 2)
 1170   1          {
 1171   2              reduce = sqrt(QLAD) - sqrt(QRAD) + sqrt(XLAD) - sqrt(XLAD);
 1172   2              plus = QLAD + QRAD + MAD + XLAD + XRAD;
 1173   2              rp = (reduce / plus) * b; // b=420;
 1174   2              error_value_old = error_value;
 1175   2              error_value = rp;
 1176   2              Kp = 1.2;
 1177   2              Kd = 3.0;
 1178   2              Error_angle_out = Kp * error_value + Kd * (error_value - error_value_old);
 1179   2              Steer_duty = (Error_angle_out + S3010_mid);
 1180   2              pwm_duty(PWMB_CH1_P74, Steer_duty);
 1181   2              cnt += 1;
 1182   2              if (cnt > ruku_time)
 1183   2              {
 1184   3                  cnt = 0;
 1185   3                  inku = 3;
 1186   3              }
 1187   2          }
 1188   1          if (inku == 3)
 1189   1          {
 1190   2              if (library == 0)
 1191   2              {
 1192   3                  Error_angle_out = -72;
 1193   3              }
 1194   2              else if (library != 0)
 1195   2                  Error_angle_out = 72;
 1196   2              Steer_duty = (Error_angle_out + S3010_mid);
 1197   2              pwm_duty(PWMB_CH1_P74, Steer_duty);
 1198   2              base = -200;
 1199   2              yaw_chuku = Yaw;
 1200   2              inku = 4;
 1201   2          }
 1202   1          if (abs(Yaw - yaw_chuku) >= 65 && inku == 4)
 1203   1          {
 1204   2              Steer_duty = (S3010_mid);
 1205   2              pwm_duty(PWMB_CH1_P74, Steer_duty);
 1206   2              BEEP = 1;
 1207   2              ruku_lucheng = road_sum;
 1208   2              inku = 5;
 1209   2          }
 1210   1          if (inku == 5)
 1211   1          {
 1212   2              base = -200;
 1213   2              if ((road_sum - ruku_lucheng) < (-0.6))
 1214   2              {
 1215   3                  base = 0;
 1216   3                  BEEP = 0;
 1217   3              }
 1218   2          }
 1219   1      }
*** WARNING C183 IN LINE 354 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 358 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 358 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 358 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 358 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 358 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 358 OF Seror.c: dead assignment eliminated
C251 COMPILER V5.60.0,  Seror                                                              25/09/22  22:19:05  PAGE 20  

*** WARNING C184 IN LINE 406 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 464 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 454 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 465 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 467 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 468 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 471 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 472 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 473 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C183 IN LINE 552 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 556 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 556 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 556 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 556 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 556 OF Seror.c: dead assignment eliminated
*** WARNING C183 IN LINE 556 OF Seror.c: dead assignment eliminated
*** WARNING C184 IN LINE 604 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 662 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 652 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 663 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 665 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 666 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 669 OF Seror.c: value of 'DF' possibly undefined
*** WARNING C184 IN LINE 670 OF Seror.c: value of 'PF' possibly undefined
*** WARNING C184 IN LINE 671 OF Seror.c: value of 'PF' possibly undefined


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      8199     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       210        444
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       972     ------
End of Module Information.


C251 COMPILATION COMPLETE.  32 WARNING(S),  0 ERROR(S)
